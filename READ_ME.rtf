{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 AndaleMono;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red14\green14\blue14;
\red255\green255\blue255;}
{\*\expandedcolortbl;;\csgenericrgb\c0\c0\c0;\csgenericrgb\c100000\c100000\c100000;\cssrgb\c6667\c6667\c6667;
\cssrgb\c100000\c100000\c100000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 READ_ME\
\cf2 \cb3 to compile: 
\f1 \CocoaLigature0 g++ -std=c++11 main.cpp Process.cpp CPUScheduler.cpp\

\f0 to execute:
\f1  ./a.out\
\
\pard\pardeftab720\sl440\sa200\partightenfactor0

\f2\fs37\fsmilli18667 \cf4 \cb5 \expnd0\expndtw0\kerning0
\CocoaLigature1 \outl0\strokewidth0 \strokec4 A program that simulates some aspects of operating systems. There is no real system programming involved. The whole simulation is based on the text inputs that the program receives from user.\cb1 \uc0\u8232 \cb5 \'a0\cb1 \uc0\u8232 \cb5 Scheduling: your program should\'a0
\fs37\fsmilli18667 \ul use multilevel feedback queue scheduling
\fs37\fsmilli18667 \ulnone . Top level 0 queue uses RR scheduling with a single time quantum. Level 1 queue uses RR scheduling with a double time quantum. \'a0Lowest level 2 queue uses FCFS approach. Each process starts at the level 0 queue. Each time the process exceeds its time limit (in other words, each time the process is preempted by the q command) it goes one level lower. We do not implement any mechanics to move processes up the levels.\cb1 \uc0\u8232 \cb5 The process arriving to a higher-level queue preempts running process from the lower-level queue. The process preempted by the higher-level process returns to the head of its queue. The process from the lower-level queue can run only if all higher queues are empty.\cb1 \uc0\u8232 \cb5 \'a0\cb1 \uc0\u8232 \cb5 All I/O-queues are\'a0
\fs37\fsmilli18667 \ul FCFS
\fs37\fsmilli18667 \ulnone .\cb1 \uc0\u8232 \cb5 \'a0\cb1 \uc0\u8232 \cb5 Memory: your program should simulate\'a0
\fs37\fsmilli18667 \ul demand paging
\fs37\fsmilli18667 \ulnone \'a0memory management. When a new process appears in the system, its page #0 is loaded into memory. Later pages are added only when needed (when corresponding m command is used). If page needs to be loaded into memory but there is no place for it, swap from the RAM the least recently used page (it can belong to any process).\'a0\cb1 \uc0\u8232 \cb5 \'a0\cb1 \uc0\u8232 \cb5 \'a0\cb1 \uc0\u8232 \cb5 At the start, your program asks the user three questions:
\f3\fs20 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl440\partightenfactor0
\ls1\ilvl0
\f2\fs37\fsmilli18667 \cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 How much RAM memory is there on the simulated computer? Your program receives the number in bytes (no kilobytes or words). I can enter any number up to 4000000000 (4 billions).\cb1 \
\ls1\ilvl0\cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 What is the size of a page/frame. The enumeration of pages starts from 0.How many hard disks does the simulated computer have? The enumeration of the hard disks starts with 0.\cb1 \
\ls1\ilvl0\cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 After these questions are answered, the simulation begins. You program constantly listens for the user inputs. You should NOT ask for a confirmation to enter another input. The user inputs signal some system events. Your program simulates the corresponding system behavior.\cb1 \
\pard\pardeftab720\sl440\sa373\partightenfactor0
\cf4 \cb5 The possible inputs are:\

\b A
\b0 \'a0\'a0\'a0\'a0\'a0\'a0 \'91A\'92 input means that a new process has been created.\'a0\
When a new process arrives, your program should create its PCB and allocate memory for it\'92s first page (page #0).\
Also, when a new process is created your program should send it to the top level of the ready-queue or allow it to use the CPU right away.\
When choosing a PID for the new process start from 1 and go up. Do NOT reuse PIDs of the terminated processes.\

\b Q
\b0 \'a0\'a0\'a0\'a0\'a0\'a0 The currently running process has spent a time quantum using the CPU. If the same process continues to use the CPU and one more Q command arrives, it means that the process has spent one more time quantum.\

\b t\'a0
\b0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 The process that is currently using the CPU terminates. It leaves the system immediately. Make sure you release the memory used by this process.\'a0\

\b d number file_name
\b0 \'a0\'a0\'a0\'a0\'a0\'a0 The process that currently uses the CPU requests the hard disk #number. It wants to read or write file file_name.\

\b D number
\b0 \'a0\'a0 The hard disk #number has finished the work for one process.\

\b m address
\b0 \'a0\'a0 The process that is currently using the CPU requests a memory operation for the logical address.\

\b S r
\b0 \'a0\'a0\'a0\'a0 Shows what process is currently using the CPU and what processes are waiting in the ready-queue.\'a0\

\b S i
\b0 \'a0\'a0\'a0\'a0\'a0 Shows what processes are currently using the hard disks and what processes are waiting to use them. For each busy hard disk show the process that uses it and show its I/O-queue. Make sure to display the filenames (from the d command) for each process. The enumeration of hard disks starts from 0.\

\b S m
\b0 \'a0\'a0 Shows the state of memory. For each used frame display the process number that occupies it and the page number stored in it. The enumeration of pages and frames starts from 0.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \cb3 \kerning1\expnd0\expndtw0 \CocoaLigature0 \outl0\strokewidth0 \
}